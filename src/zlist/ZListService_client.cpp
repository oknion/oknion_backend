/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "ZListService.h"

#include "ZListService.tcc"

#include <thrift/lib/cpp2/protocol/BinaryProtocol.h>
#include <thrift/lib/cpp2/protocol/CompactProtocol.h>
namespace zingme { namespace zlist { namespace thrift { namespace cpp2 {

const char* ZListServiceAsyncClient::getServiceName() {
  return "ZListService";
}

void ZListServiceAsyncClient::getSlice(std::unique_ptr<apache::thrift::RequestCallback> callback,  ::zingme::zlist::thrift::cpp2::ZKey key, int32_t pos, int32_t count) {
  ::apache::thrift::RpcOptions rpcOptions;
  getSlice(rpcOptions, std::move(callback), key, pos, count);
}

void ZListServiceAsyncClient::getSlice(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback,  ::zingme::zlist::thrift::cpp2::ZKey key, int32_t pos, int32_t count) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getSliceT(&writer, rpcOptions, std::move(callback), key, pos, count);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getSliceT(&writer, rpcOptions, std::move(callback), key, pos, count);
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

void ZListServiceAsyncClient::sync_getSlice( ::zingme::zlist::thrift::cpp2::ZListResult& _return,  ::zingme::zlist::thrift::cpp2::ZKey key, int32_t pos, int32_t count) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getSlice(rpcOptions, _return, key, pos, count);
}

void ZListServiceAsyncClient::sync_getSlice(apache::thrift::RpcOptions& rpcOptions,  ::zingme::zlist::thrift::cpp2::ZListResult& _return,  ::zingme::zlist::thrift::cpp2::ZKey key, int32_t pos, int32_t count) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback16 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  getSlice(rpcOptions, std::move(callback16), key, pos, count);
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  recv_getSlice(_return, _returnState);
}

folly::Future< ::zingme::zlist::thrift::cpp2::ZListResult> ZListServiceAsyncClient::future_getSlice( ::zingme::zlist::thrift::cpp2::ZKey key, int32_t pos, int32_t count) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getSlice(rpcOptions, key, pos, count);
}

folly::Future< ::zingme::zlist::thrift::cpp2::ZListResult> ZListServiceAsyncClient::future_getSlice(apache::thrift::RpcOptions& rpcOptions,  ::zingme::zlist::thrift::cpp2::ZKey key, int32_t pos, int32_t count) {
  folly::Promise< ::zingme::zlist::thrift::cpp2::ZListResult> promise17;
  auto future18 = promise17.getFuture();
  auto callback19 = folly::make_unique<apache::thrift::FutureCallback< ::zingme::zlist::thrift::cpp2::ZListResult>>(std::move(promise17), recv_wrapped_getSlice, channel_);
  getSlice(rpcOptions, std::move(callback19), key, pos, count);
  return future18;
}

folly::Future<std::pair< ::zingme::zlist::thrift::cpp2::ZListResult, std::unique_ptr<apache::thrift::transport::THeader>>> ZListServiceAsyncClient::header_future_getSlice(apache::thrift::RpcOptions& rpcOptions,  ::zingme::zlist::thrift::cpp2::ZKey key, int32_t pos, int32_t count) {
  folly::Promise<std::pair< ::zingme::zlist::thrift::cpp2::ZListResult, std::unique_ptr<apache::thrift::transport::THeader>>> promise20;
  auto future21 = promise20.getFuture();
  auto callback22 = folly::make_unique<apache::thrift::HeaderFutureCallback< ::zingme::zlist::thrift::cpp2::ZListResult>>(std::move(promise20), recv_wrapped_getSlice, channel_);
  getSlice(rpcOptions, std::move(callback22), key, pos, count);
  return future21;
}

void ZListServiceAsyncClient::getSlice(std::function<void (::apache::thrift::ClientReceiveState&&)> callback,  ::zingme::zlist::thrift::cpp2::ZKey key, int32_t pos, int32_t count) {
  getSlice(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)),key,pos,count);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_wrapped_getSlice( ::zingme::zlist::thrift::cpp2::ZListResult& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_getSliceT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_getSliceT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ZListServiceAsyncClient::recv_getSlice( ::zingme::zlist::thrift::cpp2::ZListResult& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getSlice(_return, state);
  if (ew) {
    ew.throwException();
  }
}

void ZListServiceAsyncClient::recv_instance_getSlice( ::zingme::zlist::thrift::cpp2::ZListResult& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getSlice(_return, state);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_instance_wrapped_getSlice( ::zingme::zlist::thrift::cpp2::ZListResult& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getSlice(_return, state);
}

void ZListServiceAsyncClient::rgetSlice(std::unique_ptr<apache::thrift::RequestCallback> callback,  ::zingme::zlist::thrift::cpp2::ZKey key, int32_t pos, int32_t count) {
  ::apache::thrift::RpcOptions rpcOptions;
  rgetSlice(rpcOptions, std::move(callback), key, pos, count);
}

void ZListServiceAsyncClient::rgetSlice(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback,  ::zingme::zlist::thrift::cpp2::ZKey key, int32_t pos, int32_t count) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      rgetSliceT(&writer, rpcOptions, std::move(callback), key, pos, count);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      rgetSliceT(&writer, rpcOptions, std::move(callback), key, pos, count);
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

void ZListServiceAsyncClient::sync_rgetSlice( ::zingme::zlist::thrift::cpp2::ZListResult& _return,  ::zingme::zlist::thrift::cpp2::ZKey key, int32_t pos, int32_t count) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_rgetSlice(rpcOptions, _return, key, pos, count);
}

void ZListServiceAsyncClient::sync_rgetSlice(apache::thrift::RpcOptions& rpcOptions,  ::zingme::zlist::thrift::cpp2::ZListResult& _return,  ::zingme::zlist::thrift::cpp2::ZKey key, int32_t pos, int32_t count) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback23 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  rgetSlice(rpcOptions, std::move(callback23), key, pos, count);
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  recv_rgetSlice(_return, _returnState);
}

folly::Future< ::zingme::zlist::thrift::cpp2::ZListResult> ZListServiceAsyncClient::future_rgetSlice( ::zingme::zlist::thrift::cpp2::ZKey key, int32_t pos, int32_t count) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_rgetSlice(rpcOptions, key, pos, count);
}

folly::Future< ::zingme::zlist::thrift::cpp2::ZListResult> ZListServiceAsyncClient::future_rgetSlice(apache::thrift::RpcOptions& rpcOptions,  ::zingme::zlist::thrift::cpp2::ZKey key, int32_t pos, int32_t count) {
  folly::Promise< ::zingme::zlist::thrift::cpp2::ZListResult> promise24;
  auto future25 = promise24.getFuture();
  auto callback26 = folly::make_unique<apache::thrift::FutureCallback< ::zingme::zlist::thrift::cpp2::ZListResult>>(std::move(promise24), recv_wrapped_rgetSlice, channel_);
  rgetSlice(rpcOptions, std::move(callback26), key, pos, count);
  return future25;
}

folly::Future<std::pair< ::zingme::zlist::thrift::cpp2::ZListResult, std::unique_ptr<apache::thrift::transport::THeader>>> ZListServiceAsyncClient::header_future_rgetSlice(apache::thrift::RpcOptions& rpcOptions,  ::zingme::zlist::thrift::cpp2::ZKey key, int32_t pos, int32_t count) {
  folly::Promise<std::pair< ::zingme::zlist::thrift::cpp2::ZListResult, std::unique_ptr<apache::thrift::transport::THeader>>> promise27;
  auto future28 = promise27.getFuture();
  auto callback29 = folly::make_unique<apache::thrift::HeaderFutureCallback< ::zingme::zlist::thrift::cpp2::ZListResult>>(std::move(promise27), recv_wrapped_rgetSlice, channel_);
  rgetSlice(rpcOptions, std::move(callback29), key, pos, count);
  return future28;
}

void ZListServiceAsyncClient::rgetSlice(std::function<void (::apache::thrift::ClientReceiveState&&)> callback,  ::zingme::zlist::thrift::cpp2::ZKey key, int32_t pos, int32_t count) {
  rgetSlice(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)),key,pos,count);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_wrapped_rgetSlice( ::zingme::zlist::thrift::cpp2::ZListResult& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_rgetSliceT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_rgetSliceT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ZListServiceAsyncClient::recv_rgetSlice( ::zingme::zlist::thrift::cpp2::ZListResult& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_rgetSlice(_return, state);
  if (ew) {
    ew.throwException();
  }
}

void ZListServiceAsyncClient::recv_instance_rgetSlice( ::zingme::zlist::thrift::cpp2::ZListResult& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_rgetSlice(_return, state);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_instance_wrapped_rgetSlice( ::zingme::zlist::thrift::cpp2::ZListResult& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_rgetSlice(_return, state);
}

void ZListServiceAsyncClient::multiGetSlice(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, int32_t pos, int32_t count) {
  ::apache::thrift::RpcOptions rpcOptions;
  multiGetSlice(rpcOptions, std::move(callback), keys, pos, count);
}

void ZListServiceAsyncClient::multiGetSlice(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, int32_t pos, int32_t count) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      multiGetSliceT(&writer, rpcOptions, std::move(callback), keys, pos, count);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      multiGetSliceT(&writer, rpcOptions, std::move(callback), keys, pos, count);
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

void ZListServiceAsyncClient::sync_multiGetSlice(std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>& _return, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, int32_t pos, int32_t count) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_multiGetSlice(rpcOptions, _return, keys, pos, count);
}

void ZListServiceAsyncClient::sync_multiGetSlice(apache::thrift::RpcOptions& rpcOptions, std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>& _return, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, int32_t pos, int32_t count) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback30 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  multiGetSlice(rpcOptions, std::move(callback30), keys, pos, count);
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  recv_multiGetSlice(_return, _returnState);
}

folly::Future<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>> ZListServiceAsyncClient::future_multiGetSlice(const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, int32_t pos, int32_t count) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_multiGetSlice(rpcOptions, keys, pos, count);
}

folly::Future<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>> ZListServiceAsyncClient::future_multiGetSlice(apache::thrift::RpcOptions& rpcOptions, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, int32_t pos, int32_t count) {
  folly::Promise<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>> promise31;
  auto future32 = promise31.getFuture();
  auto callback33 = folly::make_unique<apache::thrift::FutureCallback<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>>>(std::move(promise31), recv_wrapped_multiGetSlice, channel_);
  multiGetSlice(rpcOptions, std::move(callback33), keys, pos, count);
  return future32;
}

folly::Future<std::pair<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>, std::unique_ptr<apache::thrift::transport::THeader>>> ZListServiceAsyncClient::header_future_multiGetSlice(apache::thrift::RpcOptions& rpcOptions, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, int32_t pos, int32_t count) {
  folly::Promise<std::pair<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>, std::unique_ptr<apache::thrift::transport::THeader>>> promise34;
  auto future35 = promise34.getFuture();
  auto callback36 = folly::make_unique<apache::thrift::HeaderFutureCallback<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>>>(std::move(promise34), recv_wrapped_multiGetSlice, channel_);
  multiGetSlice(rpcOptions, std::move(callback36), keys, pos, count);
  return future35;
}

void ZListServiceAsyncClient::multiGetSlice(std::function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, int32_t pos, int32_t count) {
  multiGetSlice(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)),keys,pos,count);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_wrapped_multiGetSlice(std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_multiGetSliceT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_multiGetSliceT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ZListServiceAsyncClient::recv_multiGetSlice(std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_multiGetSlice(_return, state);
  if (ew) {
    ew.throwException();
  }
}

void ZListServiceAsyncClient::recv_instance_multiGetSlice(std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_multiGetSlice(_return, state);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_instance_wrapped_multiGetSlice(std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_multiGetSlice(_return, state);
}

void ZListServiceAsyncClient::rmultiGetSlice(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, int32_t pos, int32_t count) {
  ::apache::thrift::RpcOptions rpcOptions;
  rmultiGetSlice(rpcOptions, std::move(callback), keys, pos, count);
}

void ZListServiceAsyncClient::rmultiGetSlice(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, int32_t pos, int32_t count) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      rmultiGetSliceT(&writer, rpcOptions, std::move(callback), keys, pos, count);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      rmultiGetSliceT(&writer, rpcOptions, std::move(callback), keys, pos, count);
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

void ZListServiceAsyncClient::sync_rmultiGetSlice(std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>& _return, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, int32_t pos, int32_t count) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_rmultiGetSlice(rpcOptions, _return, keys, pos, count);
}

void ZListServiceAsyncClient::sync_rmultiGetSlice(apache::thrift::RpcOptions& rpcOptions, std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>& _return, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, int32_t pos, int32_t count) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback37 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  rmultiGetSlice(rpcOptions, std::move(callback37), keys, pos, count);
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  recv_rmultiGetSlice(_return, _returnState);
}

folly::Future<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>> ZListServiceAsyncClient::future_rmultiGetSlice(const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, int32_t pos, int32_t count) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_rmultiGetSlice(rpcOptions, keys, pos, count);
}

folly::Future<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>> ZListServiceAsyncClient::future_rmultiGetSlice(apache::thrift::RpcOptions& rpcOptions, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, int32_t pos, int32_t count) {
  folly::Promise<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>> promise38;
  auto future39 = promise38.getFuture();
  auto callback40 = folly::make_unique<apache::thrift::FutureCallback<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>>>(std::move(promise38), recv_wrapped_rmultiGetSlice, channel_);
  rmultiGetSlice(rpcOptions, std::move(callback40), keys, pos, count);
  return future39;
}

folly::Future<std::pair<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>, std::unique_ptr<apache::thrift::transport::THeader>>> ZListServiceAsyncClient::header_future_rmultiGetSlice(apache::thrift::RpcOptions& rpcOptions, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, int32_t pos, int32_t count) {
  folly::Promise<std::pair<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>, std::unique_ptr<apache::thrift::transport::THeader>>> promise41;
  auto future42 = promise41.getFuture();
  auto callback43 = folly::make_unique<apache::thrift::HeaderFutureCallback<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>>>(std::move(promise41), recv_wrapped_rmultiGetSlice, channel_);
  rmultiGetSlice(rpcOptions, std::move(callback43), keys, pos, count);
  return future42;
}

void ZListServiceAsyncClient::rmultiGetSlice(std::function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, int32_t pos, int32_t count) {
  rmultiGetSlice(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)),keys,pos,count);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_wrapped_rmultiGetSlice(std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_rmultiGetSliceT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_rmultiGetSliceT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ZListServiceAsyncClient::recv_rmultiGetSlice(std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_rmultiGetSlice(_return, state);
  if (ew) {
    ew.throwException();
  }
}

void ZListServiceAsyncClient::recv_instance_rmultiGetSlice(std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_rmultiGetSlice(_return, state);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_instance_wrapped_rmultiGetSlice(std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZListResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_rmultiGetSlice(_return, state);
}

void ZListServiceAsyncClient::checkExist(std::unique_ptr<apache::thrift::RequestCallback> callback,  ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  ::apache::thrift::RpcOptions rpcOptions;
  checkExist(rpcOptions, std::move(callback), key, value);
}

void ZListServiceAsyncClient::checkExist(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback,  ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      checkExistT(&writer, rpcOptions, std::move(callback), key, value);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      checkExistT(&writer, rpcOptions, std::move(callback), key, value);
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

bool ZListServiceAsyncClient::sync_checkExist( ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_checkExist(rpcOptions, key, value);
}

bool ZListServiceAsyncClient::sync_checkExist(apache::thrift::RpcOptions& rpcOptions,  ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback44 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  checkExist(rpcOptions, std::move(callback44), key, value);
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_checkExist(_returnState);
}

folly::Future<bool> ZListServiceAsyncClient::future_checkExist( ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_checkExist(rpcOptions, key, value);
}

folly::Future<bool> ZListServiceAsyncClient::future_checkExist(apache::thrift::RpcOptions& rpcOptions,  ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  folly::Promise<bool> promise45;
  auto future46 = promise45.getFuture();
  auto callback47 = folly::make_unique<apache::thrift::FutureCallback<bool>>(std::move(promise45), recv_wrapped_checkExist, channel_);
  checkExist(rpcOptions, std::move(callback47), key, value);
  return future46;
}

folly::Future<std::pair<bool, std::unique_ptr<apache::thrift::transport::THeader>>> ZListServiceAsyncClient::header_future_checkExist(apache::thrift::RpcOptions& rpcOptions,  ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  folly::Promise<std::pair<bool, std::unique_ptr<apache::thrift::transport::THeader>>> promise48;
  auto future49 = promise48.getFuture();
  auto callback50 = folly::make_unique<apache::thrift::HeaderFutureCallback<bool>>(std::move(promise48), recv_wrapped_checkExist, channel_);
  checkExist(rpcOptions, std::move(callback50), key, value);
  return future49;
}

void ZListServiceAsyncClient::checkExist(std::function<void (::apache::thrift::ClientReceiveState&&)> callback,  ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  checkExist(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)),key,value);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_wrapped_checkExist(bool& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_checkExistT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_checkExistT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

bool ZListServiceAsyncClient::recv_checkExist(::apache::thrift::ClientReceiveState& state) {
  bool _return;
  auto ew = recv_wrapped_checkExist(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

bool ZListServiceAsyncClient::recv_instance_checkExist(::apache::thrift::ClientReceiveState& state) {
  return recv_checkExist(state);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_instance_wrapped_checkExist(bool& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_checkExist(_return, state);
}

void ZListServiceAsyncClient::checkExists(std::unique_ptr<apache::thrift::RequestCallback> callback,  ::zingme::zlist::thrift::cpp2::ZKey key, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  ::apache::thrift::RpcOptions rpcOptions;
  checkExists(rpcOptions, std::move(callback), key, values);
}

void ZListServiceAsyncClient::checkExists(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback,  ::zingme::zlist::thrift::cpp2::ZKey key, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      checkExistsT(&writer, rpcOptions, std::move(callback), key, values);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      checkExistsT(&writer, rpcOptions, std::move(callback), key, values);
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

void ZListServiceAsyncClient::sync_checkExists(std::map< ::zingme::zlist::thrift::cpp2::ZValue, bool>& _return,  ::zingme::zlist::thrift::cpp2::ZKey key, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_checkExists(rpcOptions, _return, key, values);
}

void ZListServiceAsyncClient::sync_checkExists(apache::thrift::RpcOptions& rpcOptions, std::map< ::zingme::zlist::thrift::cpp2::ZValue, bool>& _return,  ::zingme::zlist::thrift::cpp2::ZKey key, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback51 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  checkExists(rpcOptions, std::move(callback51), key, values);
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  recv_checkExists(_return, _returnState);
}

folly::Future<std::map< ::zingme::zlist::thrift::cpp2::ZValue, bool>> ZListServiceAsyncClient::future_checkExists( ::zingme::zlist::thrift::cpp2::ZKey key, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_checkExists(rpcOptions, key, values);
}

folly::Future<std::map< ::zingme::zlist::thrift::cpp2::ZValue, bool>> ZListServiceAsyncClient::future_checkExists(apache::thrift::RpcOptions& rpcOptions,  ::zingme::zlist::thrift::cpp2::ZKey key, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  folly::Promise<std::map< ::zingme::zlist::thrift::cpp2::ZValue, bool>> promise52;
  auto future53 = promise52.getFuture();
  auto callback54 = folly::make_unique<apache::thrift::FutureCallback<std::map< ::zingme::zlist::thrift::cpp2::ZValue, bool>>>(std::move(promise52), recv_wrapped_checkExists, channel_);
  checkExists(rpcOptions, std::move(callback54), key, values);
  return future53;
}

folly::Future<std::pair<std::map< ::zingme::zlist::thrift::cpp2::ZValue, bool>, std::unique_ptr<apache::thrift::transport::THeader>>> ZListServiceAsyncClient::header_future_checkExists(apache::thrift::RpcOptions& rpcOptions,  ::zingme::zlist::thrift::cpp2::ZKey key, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  folly::Promise<std::pair<std::map< ::zingme::zlist::thrift::cpp2::ZValue, bool>, std::unique_ptr<apache::thrift::transport::THeader>>> promise55;
  auto future56 = promise55.getFuture();
  auto callback57 = folly::make_unique<apache::thrift::HeaderFutureCallback<std::map< ::zingme::zlist::thrift::cpp2::ZValue, bool>>>(std::move(promise55), recv_wrapped_checkExists, channel_);
  checkExists(rpcOptions, std::move(callback57), key, values);
  return future56;
}

void ZListServiceAsyncClient::checkExists(std::function<void (::apache::thrift::ClientReceiveState&&)> callback,  ::zingme::zlist::thrift::cpp2::ZKey key, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  checkExists(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)),key,values);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_wrapped_checkExists(std::map< ::zingme::zlist::thrift::cpp2::ZValue, bool>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_checkExistsT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_checkExistsT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ZListServiceAsyncClient::recv_checkExists(std::map< ::zingme::zlist::thrift::cpp2::ZValue, bool>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_checkExists(_return, state);
  if (ew) {
    ew.throwException();
  }
}

void ZListServiceAsyncClient::recv_instance_checkExists(std::map< ::zingme::zlist::thrift::cpp2::ZValue, bool>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_checkExists(_return, state);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_instance_wrapped_checkExists(std::map< ::zingme::zlist::thrift::cpp2::ZValue, bool>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_checkExists(_return, state);
}

void ZListServiceAsyncClient::checkExists2(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  ::apache::thrift::RpcOptions rpcOptions;
  checkExists2(rpcOptions, std::move(callback), keys, value);
}

void ZListServiceAsyncClient::checkExists2(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      checkExists2T(&writer, rpcOptions, std::move(callback), keys, value);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      checkExists2T(&writer, rpcOptions, std::move(callback), keys, value);
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

void ZListServiceAsyncClient::sync_checkExists2(std::map< ::zingme::zlist::thrift::cpp2::ZKey, bool>& _return, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_checkExists2(rpcOptions, _return, keys, value);
}

void ZListServiceAsyncClient::sync_checkExists2(apache::thrift::RpcOptions& rpcOptions, std::map< ::zingme::zlist::thrift::cpp2::ZKey, bool>& _return, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback58 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  checkExists2(rpcOptions, std::move(callback58), keys, value);
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  recv_checkExists2(_return, _returnState);
}

folly::Future<std::map< ::zingme::zlist::thrift::cpp2::ZKey, bool>> ZListServiceAsyncClient::future_checkExists2(const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_checkExists2(rpcOptions, keys, value);
}

folly::Future<std::map< ::zingme::zlist::thrift::cpp2::ZKey, bool>> ZListServiceAsyncClient::future_checkExists2(apache::thrift::RpcOptions& rpcOptions, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  folly::Promise<std::map< ::zingme::zlist::thrift::cpp2::ZKey, bool>> promise59;
  auto future60 = promise59.getFuture();
  auto callback61 = folly::make_unique<apache::thrift::FutureCallback<std::map< ::zingme::zlist::thrift::cpp2::ZKey, bool>>>(std::move(promise59), recv_wrapped_checkExists2, channel_);
  checkExists2(rpcOptions, std::move(callback61), keys, value);
  return future60;
}

folly::Future<std::pair<std::map< ::zingme::zlist::thrift::cpp2::ZKey, bool>, std::unique_ptr<apache::thrift::transport::THeader>>> ZListServiceAsyncClient::header_future_checkExists2(apache::thrift::RpcOptions& rpcOptions, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  folly::Promise<std::pair<std::map< ::zingme::zlist::thrift::cpp2::ZKey, bool>, std::unique_ptr<apache::thrift::transport::THeader>>> promise62;
  auto future63 = promise62.getFuture();
  auto callback64 = folly::make_unique<apache::thrift::HeaderFutureCallback<std::map< ::zingme::zlist::thrift::cpp2::ZKey, bool>>>(std::move(promise62), recv_wrapped_checkExists2, channel_);
  checkExists2(rpcOptions, std::move(callback64), keys, value);
  return future63;
}

void ZListServiceAsyncClient::checkExists2(std::function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  checkExists2(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)),keys,value);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_wrapped_checkExists2(std::map< ::zingme::zlist::thrift::cpp2::ZKey, bool>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_checkExists2T(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_checkExists2T(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ZListServiceAsyncClient::recv_checkExists2(std::map< ::zingme::zlist::thrift::cpp2::ZKey, bool>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_checkExists2(_return, state);
  if (ew) {
    ew.throwException();
  }
}

void ZListServiceAsyncClient::recv_instance_checkExists2(std::map< ::zingme::zlist::thrift::cpp2::ZKey, bool>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_checkExists2(_return, state);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_instance_wrapped_checkExists2(std::map< ::zingme::zlist::thrift::cpp2::ZKey, bool>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_checkExists2(_return, state);
}

void ZListServiceAsyncClient::put(std::unique_ptr<apache::thrift::RequestCallback> callback,  ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  ::apache::thrift::RpcOptions rpcOptions;
  put(rpcOptions, std::move(callback), key, value);
}

void ZListServiceAsyncClient::put(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback,  ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      putT(&writer, rpcOptions, std::move(callback), key, value);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      putT(&writer, rpcOptions, std::move(callback), key, value);
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

void ZListServiceAsyncClient::sync_put( ::zingme::zlist::thrift::cpp2::ZCountResult& _return,  ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_put(rpcOptions, _return, key, value);
}

void ZListServiceAsyncClient::sync_put(apache::thrift::RpcOptions& rpcOptions,  ::zingme::zlist::thrift::cpp2::ZCountResult& _return,  ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback65 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  put(rpcOptions, std::move(callback65), key, value);
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  recv_put(_return, _returnState);
}

folly::Future< ::zingme::zlist::thrift::cpp2::ZCountResult> ZListServiceAsyncClient::future_put( ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_put(rpcOptions, key, value);
}

folly::Future< ::zingme::zlist::thrift::cpp2::ZCountResult> ZListServiceAsyncClient::future_put(apache::thrift::RpcOptions& rpcOptions,  ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  folly::Promise< ::zingme::zlist::thrift::cpp2::ZCountResult> promise66;
  auto future67 = promise66.getFuture();
  auto callback68 = folly::make_unique<apache::thrift::FutureCallback< ::zingme::zlist::thrift::cpp2::ZCountResult>>(std::move(promise66), recv_wrapped_put, channel_);
  put(rpcOptions, std::move(callback68), key, value);
  return future67;
}

folly::Future<std::pair< ::zingme::zlist::thrift::cpp2::ZCountResult, std::unique_ptr<apache::thrift::transport::THeader>>> ZListServiceAsyncClient::header_future_put(apache::thrift::RpcOptions& rpcOptions,  ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  folly::Promise<std::pair< ::zingme::zlist::thrift::cpp2::ZCountResult, std::unique_ptr<apache::thrift::transport::THeader>>> promise69;
  auto future70 = promise69.getFuture();
  auto callback71 = folly::make_unique<apache::thrift::HeaderFutureCallback< ::zingme::zlist::thrift::cpp2::ZCountResult>>(std::move(promise69), recv_wrapped_put, channel_);
  put(rpcOptions, std::move(callback71), key, value);
  return future70;
}

void ZListServiceAsyncClient::put(std::function<void (::apache::thrift::ClientReceiveState&&)> callback,  ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  put(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)),key,value);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_wrapped_put( ::zingme::zlist::thrift::cpp2::ZCountResult& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_putT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_putT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ZListServiceAsyncClient::recv_put( ::zingme::zlist::thrift::cpp2::ZCountResult& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_put(_return, state);
  if (ew) {
    ew.throwException();
  }
}

void ZListServiceAsyncClient::recv_instance_put( ::zingme::zlist::thrift::cpp2::ZCountResult& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_put(_return, state);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_instance_wrapped_put( ::zingme::zlist::thrift::cpp2::ZCountResult& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_put(_return, state);
}

void ZListServiceAsyncClient::multiPut(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  ::apache::thrift::RpcOptions rpcOptions;
  multiPut(rpcOptions, std::move(callback), keys, values);
}

void ZListServiceAsyncClient::multiPut(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      multiPutT(&writer, rpcOptions, std::move(callback), keys, values);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      multiPutT(&writer, rpcOptions, std::move(callback), keys, values);
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

void ZListServiceAsyncClient::sync_multiPut(std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>& _return, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_multiPut(rpcOptions, _return, keys, values);
}

void ZListServiceAsyncClient::sync_multiPut(apache::thrift::RpcOptions& rpcOptions, std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>& _return, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback72 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  multiPut(rpcOptions, std::move(callback72), keys, values);
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  recv_multiPut(_return, _returnState);
}

folly::Future<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>> ZListServiceAsyncClient::future_multiPut(const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_multiPut(rpcOptions, keys, values);
}

folly::Future<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>> ZListServiceAsyncClient::future_multiPut(apache::thrift::RpcOptions& rpcOptions, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  folly::Promise<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>> promise73;
  auto future74 = promise73.getFuture();
  auto callback75 = folly::make_unique<apache::thrift::FutureCallback<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>>>(std::move(promise73), recv_wrapped_multiPut, channel_);
  multiPut(rpcOptions, std::move(callback75), keys, values);
  return future74;
}

folly::Future<std::pair<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>, std::unique_ptr<apache::thrift::transport::THeader>>> ZListServiceAsyncClient::header_future_multiPut(apache::thrift::RpcOptions& rpcOptions, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  folly::Promise<std::pair<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>, std::unique_ptr<apache::thrift::transport::THeader>>> promise76;
  auto future77 = promise76.getFuture();
  auto callback78 = folly::make_unique<apache::thrift::HeaderFutureCallback<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>>>(std::move(promise76), recv_wrapped_multiPut, channel_);
  multiPut(rpcOptions, std::move(callback78), keys, values);
  return future77;
}

void ZListServiceAsyncClient::multiPut(std::function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  multiPut(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)),keys,values);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_wrapped_multiPut(std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_multiPutT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_multiPutT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ZListServiceAsyncClient::recv_multiPut(std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_multiPut(_return, state);
  if (ew) {
    ew.throwException();
  }
}

void ZListServiceAsyncClient::recv_instance_multiPut(std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_multiPut(_return, state);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_instance_wrapped_multiPut(std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_multiPut(_return, state);
}

void ZListServiceAsyncClient::remove(std::unique_ptr<apache::thrift::RequestCallback> callback,  ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  ::apache::thrift::RpcOptions rpcOptions;
  remove(rpcOptions, std::move(callback), key, value);
}

void ZListServiceAsyncClient::remove(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback,  ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      removeT(&writer, rpcOptions, std::move(callback), key, value);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      removeT(&writer, rpcOptions, std::move(callback), key, value);
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

void ZListServiceAsyncClient::sync_remove( ::zingme::zlist::thrift::cpp2::ZCountResult& _return,  ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_remove(rpcOptions, _return, key, value);
}

void ZListServiceAsyncClient::sync_remove(apache::thrift::RpcOptions& rpcOptions,  ::zingme::zlist::thrift::cpp2::ZCountResult& _return,  ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback79 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  remove(rpcOptions, std::move(callback79), key, value);
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  recv_remove(_return, _returnState);
}

folly::Future< ::zingme::zlist::thrift::cpp2::ZCountResult> ZListServiceAsyncClient::future_remove( ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_remove(rpcOptions, key, value);
}

folly::Future< ::zingme::zlist::thrift::cpp2::ZCountResult> ZListServiceAsyncClient::future_remove(apache::thrift::RpcOptions& rpcOptions,  ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  folly::Promise< ::zingme::zlist::thrift::cpp2::ZCountResult> promise80;
  auto future81 = promise80.getFuture();
  auto callback82 = folly::make_unique<apache::thrift::FutureCallback< ::zingme::zlist::thrift::cpp2::ZCountResult>>(std::move(promise80), recv_wrapped_remove, channel_);
  remove(rpcOptions, std::move(callback82), key, value);
  return future81;
}

folly::Future<std::pair< ::zingme::zlist::thrift::cpp2::ZCountResult, std::unique_ptr<apache::thrift::transport::THeader>>> ZListServiceAsyncClient::header_future_remove(apache::thrift::RpcOptions& rpcOptions,  ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  folly::Promise<std::pair< ::zingme::zlist::thrift::cpp2::ZCountResult, std::unique_ptr<apache::thrift::transport::THeader>>> promise83;
  auto future84 = promise83.getFuture();
  auto callback85 = folly::make_unique<apache::thrift::HeaderFutureCallback< ::zingme::zlist::thrift::cpp2::ZCountResult>>(std::move(promise83), recv_wrapped_remove, channel_);
  remove(rpcOptions, std::move(callback85), key, value);
  return future84;
}

void ZListServiceAsyncClient::remove(std::function<void (::apache::thrift::ClientReceiveState&&)> callback,  ::zingme::zlist::thrift::cpp2::ZKey key,  ::zingme::zlist::thrift::cpp2::ZValue value) {
  remove(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)),key,value);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_wrapped_remove( ::zingme::zlist::thrift::cpp2::ZCountResult& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_removeT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_removeT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ZListServiceAsyncClient::recv_remove( ::zingme::zlist::thrift::cpp2::ZCountResult& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_remove(_return, state);
  if (ew) {
    ew.throwException();
  }
}

void ZListServiceAsyncClient::recv_instance_remove( ::zingme::zlist::thrift::cpp2::ZCountResult& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_remove(_return, state);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_instance_wrapped_remove( ::zingme::zlist::thrift::cpp2::ZCountResult& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_remove(_return, state);
}

void ZListServiceAsyncClient::removeKey(std::unique_ptr<apache::thrift::RequestCallback> callback,  ::zingme::zlist::thrift::cpp2::ZKey key) {
  ::apache::thrift::RpcOptions rpcOptions;
  removeKey(rpcOptions, std::move(callback), key);
}

void ZListServiceAsyncClient::removeKey(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback,  ::zingme::zlist::thrift::cpp2::ZKey key) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      removeKeyT(&writer, rpcOptions, std::move(callback), key);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      removeKeyT(&writer, rpcOptions, std::move(callback), key);
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

int32_t ZListServiceAsyncClient::sync_removeKey( ::zingme::zlist::thrift::cpp2::ZKey key) {
  ::apache::thrift::RpcOptions rpcOptions;
  return sync_removeKey(rpcOptions, key);
}

int32_t ZListServiceAsyncClient::sync_removeKey(apache::thrift::RpcOptions& rpcOptions,  ::zingme::zlist::thrift::cpp2::ZKey key) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback86 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  removeKey(rpcOptions, std::move(callback86), key);
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  return recv_removeKey(_returnState);
}

folly::Future<int32_t> ZListServiceAsyncClient::future_removeKey( ::zingme::zlist::thrift::cpp2::ZKey key) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_removeKey(rpcOptions, key);
}

folly::Future<int32_t> ZListServiceAsyncClient::future_removeKey(apache::thrift::RpcOptions& rpcOptions,  ::zingme::zlist::thrift::cpp2::ZKey key) {
  folly::Promise<int32_t> promise87;
  auto future88 = promise87.getFuture();
  auto callback89 = folly::make_unique<apache::thrift::FutureCallback<int32_t>>(std::move(promise87), recv_wrapped_removeKey, channel_);
  removeKey(rpcOptions, std::move(callback89), key);
  return future88;
}

folly::Future<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> ZListServiceAsyncClient::header_future_removeKey(apache::thrift::RpcOptions& rpcOptions,  ::zingme::zlist::thrift::cpp2::ZKey key) {
  folly::Promise<std::pair<int32_t, std::unique_ptr<apache::thrift::transport::THeader>>> promise90;
  auto future91 = promise90.getFuture();
  auto callback92 = folly::make_unique<apache::thrift::HeaderFutureCallback<int32_t>>(std::move(promise90), recv_wrapped_removeKey, channel_);
  removeKey(rpcOptions, std::move(callback92), key);
  return future91;
}

void ZListServiceAsyncClient::removeKey(std::function<void (::apache::thrift::ClientReceiveState&&)> callback,  ::zingme::zlist::thrift::cpp2::ZKey key) {
  removeKey(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)),key);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_wrapped_removeKey(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_removeKeyT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_removeKeyT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

int32_t ZListServiceAsyncClient::recv_removeKey(::apache::thrift::ClientReceiveState& state) {
  int32_t _return;
  auto ew = recv_wrapped_removeKey(_return, state);
  if (ew) {
    ew.throwException();
  }
  return _return;
}

int32_t ZListServiceAsyncClient::recv_instance_removeKey(::apache::thrift::ClientReceiveState& state) {
  return recv_removeKey(state);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_instance_wrapped_removeKey(int32_t& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_removeKey(_return, state);
}

void ZListServiceAsyncClient::multiRemove(std::unique_ptr<apache::thrift::RequestCallback> callback, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  ::apache::thrift::RpcOptions rpcOptions;
  multiRemove(rpcOptions, std::move(callback), keys, values);
}

void ZListServiceAsyncClient::multiRemove(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      multiRemoveT(&writer, rpcOptions, std::move(callback), keys, values);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      multiRemoveT(&writer, rpcOptions, std::move(callback), keys, values);
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

void ZListServiceAsyncClient::sync_multiRemove(std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>& _return, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_multiRemove(rpcOptions, _return, keys, values);
}

void ZListServiceAsyncClient::sync_multiRemove(apache::thrift::RpcOptions& rpcOptions, std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>& _return, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback93 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  multiRemove(rpcOptions, std::move(callback93), keys, values);
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  recv_multiRemove(_return, _returnState);
}

folly::Future<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>> ZListServiceAsyncClient::future_multiRemove(const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_multiRemove(rpcOptions, keys, values);
}

folly::Future<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>> ZListServiceAsyncClient::future_multiRemove(apache::thrift::RpcOptions& rpcOptions, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  folly::Promise<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>> promise94;
  auto future95 = promise94.getFuture();
  auto callback96 = folly::make_unique<apache::thrift::FutureCallback<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>>>(std::move(promise94), recv_wrapped_multiRemove, channel_);
  multiRemove(rpcOptions, std::move(callback96), keys, values);
  return future95;
}

folly::Future<std::pair<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>, std::unique_ptr<apache::thrift::transport::THeader>>> ZListServiceAsyncClient::header_future_multiRemove(apache::thrift::RpcOptions& rpcOptions, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  folly::Promise<std::pair<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>, std::unique_ptr<apache::thrift::transport::THeader>>> promise97;
  auto future98 = promise97.getFuture();
  auto callback99 = folly::make_unique<apache::thrift::HeaderFutureCallback<std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>>>(std::move(promise97), recv_wrapped_multiRemove, channel_);
  multiRemove(rpcOptions, std::move(callback99), keys, values);
  return future98;
}

void ZListServiceAsyncClient::multiRemove(std::function<void (::apache::thrift::ClientReceiveState&&)> callback, const std::vector< ::zingme::zlist::thrift::cpp2::ZKey>& keys, const std::vector< ::zingme::zlist::thrift::cpp2::ZValue>& values) {
  multiRemove(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)),keys,values);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_wrapped_multiRemove(std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_multiRemoveT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_multiRemoveT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ZListServiceAsyncClient::recv_multiRemove(std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_multiRemove(_return, state);
  if (ew) {
    ew.throwException();
  }
}

void ZListServiceAsyncClient::recv_instance_multiRemove(std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_multiRemove(_return, state);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_instance_wrapped_multiRemove(std::map< ::zingme::zlist::thrift::cpp2::ZKey,  ::zingme::zlist::thrift::cpp2::ZCountResult>& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_multiRemove(_return, state);
}

void ZListServiceAsyncClient::getStat(std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t type) {
  ::apache::thrift::RpcOptions rpcOptions;
  getStat(rpcOptions, std::move(callback), type);
}

void ZListServiceAsyncClient::getStat(apache::thrift::RpcOptions& rpcOptions, std::unique_ptr<apache::thrift::RequestCallback> callback, int32_t type) {
  switch(getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolWriter writer;
      getStatT(&writer, rpcOptions, std::move(callback), type);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolWriter writer;
      getStatT(&writer, rpcOptions, std::move(callback), type);
      break;
    }
    default:
    {
      throw apache::thrift::TApplicationException("Could not find Protocol");
    }
  }
}

void ZListServiceAsyncClient::sync_getStat(std::string& _return, int32_t type) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_getStat(rpcOptions, _return, type);
}

void ZListServiceAsyncClient::sync_getStat(apache::thrift::RpcOptions& rpcOptions, std::string& _return, int32_t type) {
  apache::thrift::ClientReceiveState _returnState;
  auto callback100 = folly::make_unique<apache::thrift::ClientSyncCallback>(&_returnState, getChannel()->getEventBase(), false);
  getStat(rpcOptions, std::move(callback100), type);
  getChannel()->getEventBase()->loopForever();
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(_returnState.exception());
    std::rethrow_exception(_returnState.exception());
  }
  recv_getStat(_return, _returnState);
}

folly::Future<std::string> ZListServiceAsyncClient::future_getStat(int32_t type) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_getStat(rpcOptions, type);
}

folly::Future<std::string> ZListServiceAsyncClient::future_getStat(apache::thrift::RpcOptions& rpcOptions, int32_t type) {
  folly::Promise<std::string> promise101;
  auto future102 = promise101.getFuture();
  auto callback103 = folly::make_unique<apache::thrift::FutureCallback<std::string>>(std::move(promise101), recv_wrapped_getStat, channel_);
  getStat(rpcOptions, std::move(callback103), type);
  return future102;
}

folly::Future<std::pair<std::string, std::unique_ptr<apache::thrift::transport::THeader>>> ZListServiceAsyncClient::header_future_getStat(apache::thrift::RpcOptions& rpcOptions, int32_t type) {
  folly::Promise<std::pair<std::string, std::unique_ptr<apache::thrift::transport::THeader>>> promise104;
  auto future105 = promise104.getFuture();
  auto callback106 = folly::make_unique<apache::thrift::HeaderFutureCallback<std::string>>(std::move(promise104), recv_wrapped_getStat, channel_);
  getStat(rpcOptions, std::move(callback106), type);
  return future105;
}

void ZListServiceAsyncClient::getStat(std::function<void (::apache::thrift::ClientReceiveState&&)> callback, int32_t type) {
  getStat(folly::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)),type);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_wrapped_getStat(std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = state.exceptionWrapper();
  if (ew) {
    return ew;
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>("recv_ called without result");
  }
  switch(state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL:
    {
      apache::thrift::BinaryProtocolReader reader;
      return recv_wrapped_getStatT(&reader, _return, state);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL:
    {
      apache::thrift::CompactProtocolReader reader;
      return recv_wrapped_getStatT(&reader, _return, state);
    }
    default:
    {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>("Could not find Protocol");
}

void ZListServiceAsyncClient::recv_getStat(std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_getStat(_return, state);
  if (ew) {
    ew.throwException();
  }
}

void ZListServiceAsyncClient::recv_instance_getStat(std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_getStat(_return, state);
}

folly::exception_wrapper ZListServiceAsyncClient::recv_instance_wrapped_getStat(std::string& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_getStat(_return, state);
}

}}}} // zingme::zlist::thrift::cpp2
namespace apache { namespace thrift {

}} // apache::thrift